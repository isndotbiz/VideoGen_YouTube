/**
 * Flux Turbo Workflow Generator
 *
 * Generates ComfyUI workflow JSON from parameters
 * Usage: node flux_turbo_workflow.js
 */

const fs = require('fs');
const path = require('path');

class FluxTurboWorkflow {
  constructor(config = {}) {
    this.config = {
      model: config.model || 'flux1-turbo-dev-fp8.safetensors',
      lora: config.lora || 'flux_turbo_lora.safetensors',
      loraStrength: config.loraStrength || 1.0,
      width: config.width || 1920,
      height: config.height || 1080,
      steps: config.steps || 20,
      cfg: config.cfg || 3.5,
      sampler: config.sampler || 'dpmpp_2m_sde',
      scheduler: config.scheduler || 'karras',
      seed: config.seed || -1,
      denoise: config.denoise || 1.0,
      outputPrefix: config.outputPrefix || 'flux_turbo_output',
      positivePrompt: config.positivePrompt || '',
      negativePrompt: config.negativePrompt || 'blurry, low quality, distorted, ugly, bad composition, watermark, text, signature'
    };
  }

  /**
   * Generate complete workflow JSON
   */
  generateWorkflow() {
    return {
      last_node_id: 15,
      last_link_id: 20,
      nodes: this.generateNodes(),
      links: this.generateLinks(),
      groups: [],
      config: {},
      extra: {
        ds: {
          scale: 0.8,
          offset: [0, 0]
        }
      },
      version: 0.4,
      workflow_info: {
        name: 'Flux Turbo Batch Generator',
        version: '1.0',
        description: 'Optimized workflow for batch image generation using Flux Turbo model with Turbo LoRA',
        author: 'Generated by flux_turbo_workflow.js',
        timestamp: new Date().toISOString()
      }
    };
  }

  /**
   * Generate all nodes for the workflow
   */
  generateNodes() {
    return [
      this.createCheckpointLoader(),
      this.createLoraLoader(),
      this.createPositivePrompt(),
      this.createNegativePrompt(),
      this.createEmptyLatent(),
      this.createKSampler(),
      this.createVAEDecode(),
      this.createSaveImage(),
      this.createMetadataWriter(),
      this.createNotePrimary(),
      this.createNotePerformance()
    ];
  }

  /**
   * Generate all links between nodes
   */
  generateLinks() {
    return [
      [1, 1, 0, 2, 0, 'MODEL'],      // Checkpoint MODEL to LoraLoader
      [2, 1, 1, 2, 1, 'CLIP'],       // Checkpoint CLIP to LoraLoader
      [3, 1, 2, 7, 1, 'VAE'],        // Checkpoint VAE to VAEDecode
      [4, 2, 0, 6, 0, 'MODEL'],      // LoraLoader MODEL to KSampler
      [5, 2, 1, 3, 0, 'CLIP'],       // LoraLoader CLIP to Positive Prompt
      [5, 2, 1, 4, 0, 'CLIP'],       // LoraLoader CLIP to Negative Prompt
      [6, 3, 0, 6, 1, 'CONDITIONING'], // Positive to KSampler
      [7, 4, 0, 6, 2, 'CONDITIONING'], // Negative to KSampler
      [8, 5, 0, 6, 3, 'LATENT'],     // EmptyLatent to KSampler
      [9, 6, 0, 7, 0, 'LATENT'],     // KSampler to VAEDecode
      [10, 7, 0, 8, 0, 'IMAGE'],     // VAEDecode to SaveImage
      [11, 7, 0, 9, 0, 'IMAGE']      // VAEDecode to MetadataWriter
    ];
  }

  createCheckpointLoader() {
    return {
      id: 1,
      type: 'CheckpointLoaderSimple',
      pos: [50, 100],
      size: [315, 98],
      flags: {},
      order: 0,
      mode: 0,
      outputs: [
        { name: 'MODEL', type: 'MODEL', links: [1], slot_index: 0 },
        { name: 'CLIP', type: 'CLIP', links: [2], slot_index: 1 },
        { name: 'VAE', type: 'VAE', links: [3], slot_index: 2 }
      ],
      properties: { 'Node name for S&R': 'CheckpointLoaderSimple' },
      widgets_values: [this.config.model]
    };
  }

  createLoraLoader() {
    return {
      id: 2,
      type: 'LoraLoader',
      pos: [400, 100],
      size: [315, 126],
      flags: {},
      order: 1,
      mode: 0,
      inputs: [
        { name: 'model', type: 'MODEL', link: 1 },
        { name: 'clip', type: 'CLIP', link: 2 }
      ],
      outputs: [
        { name: 'MODEL', type: 'MODEL', links: [4], slot_index: 0 },
        { name: 'CLIP', type: 'CLIP', links: [5], slot_index: 1 }
      ],
      properties: { 'Node name for S&R': 'LoraLoader' },
      widgets_values: [this.config.lora, this.config.loraStrength, this.config.loraStrength]
    };
  }

  createPositivePrompt() {
    return {
      id: 3,
      type: 'CLIPTextEncode',
      pos: [400, 280],
      size: [400, 200],
      flags: {},
      order: 2,
      mode: 0,
      inputs: [{ name: 'clip', type: 'CLIP', link: 5 }],
      outputs: [{ name: 'CONDITIONING', type: 'CONDITIONING', links: [6], slot_index: 0 }],
      properties: { 'Node name for S&R': 'CLIPTextEncode' },
      widgets_values: [this.config.positivePrompt || 'A professional photograph of a modern data center, high detail, 8k resolution, dramatic lighting, cinematic composition']
    };
  }

  createNegativePrompt() {
    return {
      id: 4,
      type: 'CLIPTextEncode',
      pos: [400, 520],
      size: [400, 200],
      flags: {},
      order: 3,
      mode: 0,
      inputs: [{ name: 'clip', type: 'CLIP', link: 5 }],
      outputs: [{ name: 'CONDITIONING', type: 'CONDITIONING', links: [7], slot_index: 0 }],
      properties: { 'Node name for S&R': 'CLIPTextEncode' },
      widgets_values: [this.config.negativePrompt]
    };
  }

  createEmptyLatent() {
    return {
      id: 5,
      type: 'EmptyLatentImage',
      pos: [50, 300],
      size: [315, 106],
      flags: {},
      order: 4,
      mode: 0,
      outputs: [{ name: 'LATENT', type: 'LATENT', links: [8], slot_index: 0 }],
      properties: { 'Node name for S&R': 'EmptyLatentImage' },
      widgets_values: [this.config.width, this.config.height, 1]
    };
  }

  createKSampler() {
    return {
      id: 6,
      type: 'KSampler',
      pos: [850, 100],
      size: [315, 262],
      flags: {},
      order: 5,
      mode: 0,
      inputs: [
        { name: 'model', type: 'MODEL', link: 4 },
        { name: 'positive', type: 'CONDITIONING', link: 6 },
        { name: 'negative', type: 'CONDITIONING', link: 7 },
        { name: 'latent_image', type: 'LATENT', link: 8 }
      ],
      outputs: [{ name: 'LATENT', type: 'LATENT', links: [9], slot_index: 0 }],
      properties: { 'Node name for S&R': 'KSampler' },
      widgets_values: [
        this.config.seed,
        'randomize',
        this.config.steps,
        this.config.cfg,
        this.config.sampler,
        this.config.scheduler,
        this.config.denoise
      ]
    };
  }

  createVAEDecode() {
    return {
      id: 7,
      type: 'VAEDecode',
      pos: [1200, 100],
      size: [210, 46],
      flags: {},
      order: 6,
      mode: 0,
      inputs: [
        { name: 'samples', type: 'LATENT', link: 9 },
        { name: 'vae', type: 'VAE', link: 3 }
      ],
      outputs: [{ name: 'IMAGE', type: 'IMAGE', links: [10, 11], slot_index: 0 }],
      properties: { 'Node name for S&R': 'VAEDecode' }
    };
  }

  createSaveImage() {
    return {
      id: 8,
      type: 'SaveImage',
      pos: [1450, 100],
      size: [315, 270],
      flags: {},
      order: 7,
      mode: 0,
      inputs: [{ name: 'images', type: 'IMAGE', link: 10 }],
      properties: {},
      widgets_values: [this.config.outputPrefix]
    };
  }

  createMetadataWriter() {
    return {
      id: 9,
      type: 'ImageMetadataWriter',
      pos: [1450, 420],
      size: [315, 150],
      flags: {},
      order: 8,
      mode: 0,
      inputs: [{ name: 'image', type: 'IMAGE', link: 11 }],
      outputs: [{ name: 'IMAGE', type: 'IMAGE', links: [], slot_index: 0 }],
      properties: { 'Node name for S&R': 'ImageMetadataWriter' },
      widgets_values: [
        'Flux Turbo',
        this.config.lora,
        `${this.config.sampler} ${this.config.scheduler}`,
        this.config.steps,
        this.config.cfg
      ]
    };
  }

  createNotePrimary() {
    return {
      id: 10,
      type: 'Note',
      pos: [50, 450],
      size: [300, 150],
      flags: {},
      order: 9,
      mode: 0,
      properties: { text: '' },
      widgets_values: [
        `FLUX TURBO BATCH WORKFLOW\n\nOptimized for speed with Turbo LoRA:\n- Steps: ${this.config.steps} (fast generation)\n- CFG: ${this.config.cfg} (turbo optimized)\n- Sampler: ${this.config.sampler} ${this.config.scheduler}\n- Resolution: ${this.config.width}x${this.config.height}\n\nFor batch processing, use the Python script to submit multiple prompts automatically.`
      ],
      bgcolor: '#232',
      fgcolor: '#fff'
    };
  }

  createNotePerformance() {
    return {
      id: 11,
      type: 'Note',
      pos: [850, 400],
      size: [300, 120],
      flags: {},
      order: 10,
      mode: 0,
      properties: { text: '' },
      widgets_values: [
        'PERFORMANCE TIPS:\n\n1. Lower steps to 15 for faster generation\n2. Use FP8 model for lower VRAM usage\n3. Batch size 1 for consistent quality\n4. CFG 2.5-4.5 range works best for turbo'
      ],
      bgcolor: '#323',
      fgcolor: '#fff'
    };
  }

  /**
   * Save workflow to file
   */
  saveWorkflow(filename) {
    const workflow = this.generateWorkflow();
    fs.writeFileSync(filename, JSON.stringify(workflow, null, 2));
    console.log(`Workflow saved to ${filename}`);
    return workflow;
  }

  /**
   * Update prompt and return new workflow
   */
  withPrompt(positivePrompt, negativePrompt = null) {
    const newConfig = { ...this.config, positivePrompt };
    if (negativePrompt) {
      newConfig.negativePrompt = negativePrompt;
    }
    return new FluxTurboWorkflow(newConfig);
  }

  /**
   * Generate workflow for a list of prompts
   */
  static generateBatchWorkflows(prompts, baseConfig = {}) {
    const workflows = [];
    prompts.forEach((prompt, index) => {
      const config = {
        ...baseConfig,
        positivePrompt: prompt.text || prompt,
        outputPrefix: `${baseConfig.outputPrefix || 'flux_turbo'}_${String(index + 1).padStart(3, '0')}`
      };
      const generator = new FluxTurboWorkflow(config);
      workflows.push(generator.generateWorkflow());
    });
    return workflows;
  }
}

// Example usage
if (require.main === module) {
  // Load prompts from file if available
  let prompts = [];
  const promptsFile = path.join(__dirname, 'prompts.json');

  if (fs.existsSync(promptsFile)) {
    const promptData = JSON.parse(fs.readFileSync(promptsFile, 'utf8'));
    prompts = promptData.prompts || [];
    console.log(`Loaded ${prompts.length} prompts from prompts.json`);
  } else {
    console.log('No prompts.json found, generating sample workflow...');
    prompts = [{
      text: 'A professional photograph of a modern data center, high detail, 8k resolution, dramatic lighting, cinematic composition'
    }];
  }

  // Generate workflow for first prompt as example
  const generator = new FluxTurboWorkflow({
    positivePrompt: prompts[0].text || prompts[0],
    steps: 20,
    cfg: 3.5,
    width: 1920,
    height: 1080
  });

  generator.saveWorkflow('flux_turbo_generated.json');

  // Generate batch workflows if multiple prompts
  if (prompts.length > 1) {
    const batchWorkflows = FluxTurboWorkflow.generateBatchWorkflows(prompts, {
      steps: 20,
      cfg: 3.5,
      width: 1920,
      height: 1080,
      outputPrefix: 'flux_turbo_batch'
    });

    fs.writeFileSync(
      'flux_turbo_batch_workflows.json',
      JSON.stringify(batchWorkflows, null, 2)
    );
    console.log(`Generated ${batchWorkflows.length} batch workflows`);
  }
}

module.exports = FluxTurboWorkflow;
